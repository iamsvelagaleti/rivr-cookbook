# Introduction

## Sample Applications

### Hello World

!set branch hello-world

This example shows how to implement a simple dialogue. It only plays a single message and then hang-up.

First step is to provide an implementation of `com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogue` and code the dialogue in the `com.nuecho.rivr.core.dialogue.Dialogue#run(F, C)` method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 16-28

Next, the `web.xml` must contain:

* a `<servlet>` entry for `com.nuecho.rivr.voicexml.servlet.VoiceXmlDialogueServlet`
* an `<init-param>` specifying which dialogue class to instantiate
* a `<servlet-mapping>` entry

!inline src/main/webapp/WEB-INF/web.xml

Once compiled and deployed, the dialogue is ready to be called by the VoiceXML platform.

### Hello World 2

!set branch hello-world-2

This example shows how to perform error handling and to build a return structure.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 26-66

# Dialogue basics

## Messages

### Playing a speech synthesis message

!set branch message-speech-synthesis

To play a speech synthesis message (a.k.a. text-to-speech or TTS), a `com.nuecho.rivr.voicexml.turn.output.audio.SpeechSynthesis` object is needed:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-31

### Playing an audio file

!set branch message-audio-file

To play a prerecorded audio file, an `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile` object is needed. This object can be created by
a factory method. Here, since we want to play an audio file from a location (URI or path), we will use the
`com.nuecho.rivr.voicexml.turn.output.audio.AudioFile#fromLocation(java.lang.String)` static method. This `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile` must then be used in a `com.nuecho.rivr.voicexml.turn.output.Message` output turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-33

Note that here, the path of the audio file will be based on the _context path_, i.e. the path under which the application
is deployed on the web application server. The context path is exposed as a property of the `com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext`.

### Playing an audio file with alternate synthesis text

!set branch message-audio-file-with-alternate

It is possible to play altenate content whenever an audio cannot be played (i.e. fetch problem, bad file format, etc). The
alternate text can be specified as the second argument of the `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile#fromLocation(java.lang.String, java.lang.String)` factory method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-34

The alternate text can either be a `String` or a `com.nuecho.rivr.voicexml.turn.output.audio.SpeechSynthesis`. Either way, it will generate synthetized speech.

### Playing SSML content

!set branch message-ssml

To use SSML for speech synthesis instead of plain old text, use the `com.nuecho.rivr.voicexml.turn.output.audio.SpeechSynthesis#SpeechSynthesis(org.w3c.dom.DocumentFragment)` constructor having an `org.w3c.dom.DocumentFragment` argument.
Here's how one could build a SSML document fragment:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 32-47

This example would generate the following SSML:

    <phoneme alphabet="x-sampa" ph="rI.v@r">Rivr</phoneme>

### Playing mutiple audio items

!set branch message-multiple-items

To play multiple audio items (prerecorded audio file, speech synthesis, pause, etc...), You can make and process a series of `com.nuecho.rivr.voicexml.turn.output.Message` turns but you can also play the list of audio items in the same `com.nuecho.rivr.voicexml.turn.output.Message`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-35

### Playing a pause

!set branch message-pause

The `com.nuecho.rivr.voicexml.turn.output.audio.Pause` audio item is a way to generate a pause (i.e. a <break> element in VoiceXML). The duration of the pause must be specified with a `com.nuecho.rivr.core.util.Duration` which has some factory methods.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-35

### Specifying message language

!set branch message-language

For each message turn, you can set the `language` field:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-34

This can also be done globally at the VoiceXML level:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 35-46

### Queuing a prompt with barge-in for the next interaction

!set branch message-barge-in

First, we need to disable to fetchaudio property. Maybe the platform default is already empty, but to make sure:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-35

Then, we can queue the message with the barge-in flag set.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 37-44

Now, in the next interaction, the VoiceXML prompt queue will be flush because we are entering a _waiting state_. Since barge-in flag was set,
the user can press a digit during the message and the interaction will complete.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 46-50

## Interactions

### Collecting DTMF

!set branch simple-dtmf-interaction

This example shows how to collect a DTMF string from the caller. It involves the `com.nuecho.rivr.voicexml.turn.output.Interaction` turn which is created using the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder`.

The first thing we need to do is to create the `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition`. This object contains the DTMF grammar used for DTMF recognition.
There are a few [built-in grammars](http://www.w3.org/TR/voicexml20/#dmlABuiltins) specified in the VoiceXML specification. We are going to use `digits`.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 59-60

Then we need to build the interaction. We are going to instanciate an `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder` for this task. There is two ways to get the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder` object:

1. by calling the static method `com.nuecho.rivr.voicexml.turn.output.OutputTurns#interaction(java.lang.String)`
2. by using the constructor of `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#Interaction.Builder(java.lang.String)` directly

We'll use the first method.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Note that we've used a static import for the `com.nuecho.rivr.core.test.TestDialogueChannel#interaction(java.lang.String)` method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 7-7

Then we need to specify the prompts that we are going to use. This is done with the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#addPrompt(com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method. Here we just use a `com.nuecho.rivr.voicexml.turn.output.audio.SpeechSynthesis` message.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

To create the `com.nuecho.rivr.voicexml.turn.output.Interaction` itself, we invoke the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#build(com.nuecho.rivr.voicexml.turn.output.DtmfRecognition, com.nuecho.rivr.core.util.Duration, com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method and we pass the `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` object, meaning that we want to
perform DTMF recognition immediately after prompts are played. We also need to specify the time-out value, i.e. the time before a `no-input` event is raised.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 64-64

Now that we have an `com.nuecho.rivr.voicexml.turn.output.Interaction`, we can execute it and receive the `com.nuecho.rivr.core.channel.InputTurn` which contains the result of this interaction.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

We now need to inspect the result in order to know what has been done by the user. We are going to deal with the following two outcomes

1. The user has typed a number
2. The user hasn't enter anything

Actually, other outcomes are possible (e.g. hang-up, error) but we'll ignore that for now for the sake of simplicity.
The `com.nuecho.rivr.core.channel.InputTurn` contains a `recognitionInfo` property which gives us acces to the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-76

### Collecting DTMF with interruptible message

!set branch barge-in-dtmf-interaction

This example is very similar to [[Collecting DTMF]]. Here, we will allow the user to type the number while the prompt is being played. This behaviour is also known as _barge-in_.

In order to do that, we use a diffent signature of the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#addPrompt(com.nuecho.rivr.voicexml.turn.output.DtmfRecognition, com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method. We use the one where you can specify a `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-65

The `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` object is used twice in this statement. It is important to understand why:

1. The fact that we specify a `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` _in the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#addPrompt(com.nuecho.rivr.voicexml.turn.output.DtmfRecognition, com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method_ indicates that the user can perform input _while the prompt is playing_.
2. The fact that we specify a `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` _in the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#build(com.nuecho.rivr.voicexml.turn.output.DtmfRecognition, com.nuecho.rivr.core.util.Duration, com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method_ indicates that the user can also perform input _after the prompts are played_.

### Using a DTMF grammar

!set branch dtmf-grammar

This example shows how to use a DTMF grammar to define what should be accepted during DTMF recognition.

Here a grammar that will accept all North-American valid phone number:

!inline src/main/webapp/grammars/phone-number.grxml

Here's how this should be use in the dialogue:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 59-67

Since the grammar is very simple and it doesn't provide semantic interpration, the result can be obtain
by getting the _utterance_ property of the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 69-79

### Using a DTMF grammar with semantic tags

!set branch dtmf-grammar-with-semantic

In the other DTMF recognition examples where a built-in grammar was used, we have rather used the _interpretation_ property of the
recognition result because built-in grammars provide a _semantic interpretation_. It is better to work with the interpretation than the raw utterance.

In our previous example ([[Using a DTMF grammar]]), the optional "1" will be part of the result if the caller has pressed the key, so we must deal with the fact that
it may be present or not. In other word, we need to do the normalization in the dialogue. It's also possible that DTMF _utterance_ will
contains space between each digits (i.e. `5 1 4 5 5 5 1 2 3 4`), so there is another normalization to do there also.

If the grammar provides semantic tags, you have control over what is returned in the recognition result.
Moreover, if you are performing speech recognition and DTMF recognition at once, you can return the same format for the interpretation regardless
of the input mode (i.e. DTMF or speech), making it easier to process in the dialogue.

Here's the phone number grammar modified with semantic tags:

!inline src/main/webapp/grammars/phone-number.grxml 12-45

Here's how to access the result:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 69-79

Note that the phone number doesn't need any normalization at this point. The optional country code will not be part of the interpretation.

### DTMF recognition options

!set branch dtmf-options

This example shows how to tune DTMF recognition. The parameters describe here are explained in detail in the VoiceXML specification,
[Section 6.3.3](http://www.w3.org/TR/voicexml20/#dml6.3.3) and [Appendix D - Timing Properties / DTMF Grammar](http://www.w3.org/TR/voicexml20/#L9212)

Let's start by having a grammar accepting a DTMF string between 5 and 10 digits long.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-60

Now let's configure the _inter-digit time-out_, i.e. the maximum pause duration between the input of two consecutive digits before the input is considered finished.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 61-61

Another option you can configure is the DTMF _term char_, i.e. the DMTF key the caller can press in order to terminate the input.
This is the DTMF equivalent of the _Enter_ key. So the user can press the DTMF _term char_ once the input is done,
not having to wait for the _inter-digit time-out_.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

The last parameter is _term time-out_, i.e. the time given to enter the term char once
when no other character can be accepted (in our exemple, after the 10th digit). The idea is to put a value
for _term time-out_ that is shorter than _inter-digit time-out_ value.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

The `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` can now be used to build the `com.nuecho.rivr.voicexml.turn.output.Interaction`.
Note that the time-out specify here (2 seconds) is the _no-input time-out_ (or simply _timeout_ in the VoiceXML terminology):

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-68

You can then perform the DTMF recognition by executing the turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 69-81

### Interruptible message

!set branch interruptible-message

Sometime, it is required to play a message while giving the caller a way to interrupt it and skip the rest of it. The following example explains how to do that.

First, we need to specify a DTMF grammar accepting a single digit:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 56-57

We also reset the DTMF termination character as we want to make the pound key (#) a DTMF input.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-58

Then we create the interaction using the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder` and we only set the `com.nuecho.rivr.voicexml.turn.output.DtmfRecognition` for the prompt.
There is no arguments in the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#build()` method since we do not want to perform recognition once the message is played.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 60-66

If we need to check if the prompt has been interrupted, we can check if we got any DTMF recognition (a digit) or a no-match event (pound or asterisk). We also must check for the _hang-up_ event.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 67-78

### Performing speech-recognition

!set branch simple-speech-interaction

This example shows how to perform speech recognition. Like DTMF recognition, it involves the `com.nuecho.rivr.voicexml.turn.output.Interaction` which is created with the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder`.

The first thing we need to do is to create the `com.nuecho.rivr.voicexml.turn.output.SpeechRecognition`. This object contains the speech grammar used for speech recognition. There
are a few [built-in grammars](http://www.w3.org/TR/voicexml20/#dmlABuiltins) specified in the VoiceXML specification. We are going to use `digits`.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 59-60

Then we need to build the interaction. We are going to create an instance of `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder` for this task.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Then we need to specify the prompts that we are going to use. This is done with the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#addPrompt(com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method. Here we just use a `com.nuecho.rivr.voicexml.turn.output.audio.SpeechSynthesis` object.

To create the `com.nuecho.rivr.voicexml.turn.output.Interaction` itself, we invoke the `com.nuecho.rivr.voicexml.turn.output.Interaction.Builder#build(com.nuecho.rivr.voicexml.turn.output.SpeechRecognition, com.nuecho.rivr.core.util.Duration, com.nuecho.rivr.voicexml.turn.output.audio.AudioItem...)` method and we pass the `com.nuecho.rivr.voicexml.turn.output.SpeechRecognition` method, meaning that we want to
perform speech recognition immediately after prompts are played. We also need to specify the time-out value, i.e. the time before a `no-input` event is raise.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-64

Now that we have an `com.nuecho.rivr.voicexml.turn.output.Interaction`, we can execute it and receive the `com.nuecho.rivr.core.channel.InputTurn` which contains the result of this interaction.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

We now need to inspect the result in order to know what has been done by the user. We are going to deal with the following three outcomes:

1. The user said some digits
2. The user said something that could not be understood
3. The user didn't say anything

Actually, other outcomes are possible (e.g. hang-up, error) but we'll ignore that for the sake of simplicity.
The `com.nuecho.rivr.core.channel.InputTurn` contains a `recognitionInfo` property which gives us acces to the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-78

### Speech recognition options

!set branch speech-options

This example shows how to tune speech recognition. The parameters describe here are explained in detail in the VoiceXML specification,
[Section 6.3.2](http://www.w3.org/TR/voicexml20/#dml6.3.2) and part of [Section 6.3.6](http://www.w3.org/TR/voicexml20/#dml6.3.6)

Setting the confidence level, i.e. the minimum confidence level the result must have in order for the recognition not to throw a `nomatch` event:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Setting the right confidence level is very difficult. If you put this value too high, you will create no-matches for utterances that could have
been correct. On the other hand, setting a value too low will accept incorrect results which should have been discarded. One way to set this
value correctly is to perform various benchmarks on the recognition engine using the same grammar and a representative sample.

Setting the maximum number of hypotheses (a.k.a. _N-Best_) that should be returned by the recognition engine:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

Getting several hypotheses allows you to inspect the result and propose the other hypotheses during a confirmation dialogue. However,
for UI design reasons, you should limit those confirmations to a reasonable number. Also, asking many hypotheses is more CPU-demanding for
the recognition engine (depends on the grammar used).

Setting the incomplete time-out, i.e. maximum silence duration after end of speech:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 64-64

You may want to set this value high enough to give the user a chance to make pauses while speaking. However, if you set this value too high, it will take
longer for the engine to end the recognition and return the result. If you are only asking a yes/no question, this time-out can be short (ie. something around 500 ms).
However, if you are asking a credit card number, this should be longer because people will hesitate and will naturally insert pauses between digit groups, so in this case,
a 1500 ms value would be a good starting point.

Another time-out applying after end of speech, the _complete timeout_, can be set like this:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-65

While apparently symmetrical to _incomplete timeout_, the _complete timeout_ is a more advanced setting. The purpose of this setting is to allow the engine to
end recognition after a pause (the _complete time-out_) if a complete recognition result is _available_. If used adequatly, this can increase the responsiveness
of the recognition.

* In this example, if the user says "one two three four" and then pauses, the recognizer does not have a valid recognition result yet
because a minimum of 5 digits is required. So the _complete time-out_ does not apply here. At this point, if the pause is longer than _incomplete time-out_,
the recognition will end.
* However, if the user says "one two three four five six" and pauses, the recognizer has a valid recognition result (123456 is allowed
by the grammar) and the recognition result will end after a pause of _complete time-out_. You can see here that if the complete time-out is too short, hesitation
beyond the 5th digit will cause recognition to end, so you need to consider this while establishing the value.

The _maximum speech timeout_ is the maximum time allowed for speaking. This value should be greater than the time it reasonnably takes for someone to say a valid answer:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

If the user speak beyond this duration, the _maxspeechtimeout_ event is triggered.

The _sensitivity_ parameter allows the tuning of the speech detector for barge-in prompts:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 67-67

A value towards 0 will make it harder to barge-in and a value towards 1 will trigger the barge-in for
non-vocal sounds (e.g. clicks, background noise). Normally, we don't tune this parameter unless the context is unusual.

The _speed versus accuraccy_ parameter controls the balance beetween speed of speech recognition and accuracy of recognition results:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-68

A value towards 0 will make the recognition fast but less accurate. A value towards 1 will make the speech recognition longer
(using more CPU) but more accurate.

All the values passed to those methods can also be `null`, meaning that the platform default should be used.

### Recording

!set branch simple-recording

This example shows how to record a message from the caller.

First, a `com.nuecho.rivr.voicexml.turn.output.Recording` object must be created:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 59-59

This object allows us to define the recording behaviour. The `beep` property will make the beginning of the recording
start with a beep:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 60-60

The `postAudioToServer` (defaults to `true`, explicitly set here for the tutorial purpose) instructs the VoiceXML platform
to send back the audio file of the recording back to the server. Doing so will allow the dialogue to manipulate the payload of
the recording (typically: write the audio file on the filesystem):

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 61-61

Note: Sending the audio file to the server is not the only thing you can do with a recording. The `clientSideAssignationDestination` property can be set in
order to store the audio file in a VoiceXML variable (i.e. on the platform, the client-side) and be played later in the dialogue using an `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile`
built from an expression. See [[Recording with playback]] for more info.

The `type` property sets the audio file format:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

The `finalSilence` property specifies the silence duration required to stop the recording.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

If the `dtmfTerm` property is set, the caller can stop the recording by pressing any DTMF key:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 64-64

The `maxTime` property limits the duration of the recording:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-65

Once we have our `com.nuecho.rivr.voicexml.turn.output.Recording` we can build our interaction turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 67-71

The turn is then processed as usual:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 72-72

If the recording succeeded, the `recordingInfo` property will be set in the `com.nuecho.rivr.core.channel.InputTurn`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 75-75

The `com.nuecho.rivr.voicexml.turn.input.RecordingInfo` exposes meta-data of the recording:

* `dtmfTerm`: If the recording ended because the user pressed a DTMF key, this property will contain the latter key.
* `duration`: This contains the duration of the recording (in milliseconds).
* `maxTime`: This property is set to `true` is maximum duration is reached.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 76-79

The `com.nuecho.rivr.voicexml.turn.input.RecordingInfo` also contains the recording itself in the `file` property.

* `contentType`: This property contains the the audio file format (e.g. "audio/x-wav").
* `content`: This is the audio file itself, exposed as a `byte[]`.
* `name`: This property contains the filename of the recording, as sent by the VoiceXML platform.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 81-84

We show in this example how to store the file on disk (on the server-side).

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 86-91

Note that you must also check for the `no-input` event as the user might have remained silence and no message
has been recorded:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 92-95

### Recording with playback

!set branch recording-to-variable

It is sometimes useful to play back the recorded message to the user in order to get a confirmation. To do that,
we just need to temporarly store the audio on the VoiceXML platform. To do that, we do the same thing as in [[Recording]]
except that we add the following:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

This will store the recorded audio in a VoiceXML variable in the application
scope (we will need it later in the dialogue, that's why we need to put it in the `application` scope).

To play back the message, we need to use the `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile` audio item. Since we are going to play a previously
recorded file which is stored in a VoiceXML variable, we need to build this `com.nuecho.rivr.voicexml.turn.output.audio.AudioFile` from a JavaScript expression:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 94-97

## Call transfers

### Blind Transfer

!set branch transfer-blind

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 20-29

### Consultation transfer

!set branch transfer-consultation

First, we need to prepare the interaction:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 24-30

Now we have to deal with the result. First, we check for events:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 31-36

Then, we check the status code:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 37-51

## Subdialogues

### Invoking a subdialogue

!set branch subdialogue-invocation

This example shows how to invoke a VoiceXML subdialogue as defined in the
[VoiceXML specification](http://www.w3.org/TR/voicexml20/#dml2.3.4).

The output turn required to invoke a subdialogue is a `com.nuecho.rivr.voicexml.turn.output.SubdialogueCall`. We pass the URL of the
subdialogue in the constructor:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 25-25

The HTTP request to get the subdialogue will use the POST method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 27-27

The turn will be executed:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-29

The subdialogue return values will be placed in the `value` property of the `com.nuecho.rivr.core.channel.InputTurn`. Let's assume here
that our dialogue returned multiple named values. This will be available in the dialogue as a `JsonObject`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 31-32

Each property of the JSON object correspond to the return value:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 34-41

The sample comes with a sample VoiceXML subdialogue:

!inline src/main/webapp/subdialogue.vxml

### Invoking a subdialogue and passing HTTP parameters

!set branch subdialogue-invocation-http-parameters

This example shows how to invoke a VoiceXML subdialogue which requires HTTP parameters.

We proceed as with [[Invoking a subdialogue]] but we define a `com.nuecho.rivr.voicexml.turn.VariableList` that will contain
the various parameters. Be careful as initial value for each parameter is a JavaScript expression,
so don't forget relevant quoting:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-32

We set those parameters in the turn as _submit parameters_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-33

### Invoking a subdialogue and passing VoiceXML parameters

!set branch subdialogue-invocation-voicexml-parameters

This example shows how to invoke a VoiceXML subdialogue which requires VoiceXML parameters (i.e.
uses `<param>` elements).

We proceed as with [[Invoking a subdialogue]] but we define some `com.nuecho.rivr.voicexml.turn.output.SubdialogueCall.Parameter` objects. Those
objects will be used to create the various `<param>` elements in the generated VoiceXML, so you can either
create them with a regular _value_ or with a JavaScript _expression_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-32

The `com.nuecho.rivr.voicexml.turn.output.SubdialogueCall.Parameter#createWithValue(java.lang.String, java.lang.String)` expects the parameter name and a string value. It will yield:

```xml
    <param name="parameter1" value="string" />
```

The `com.nuecho.rivr.voicexml.turn.output.SubdialogueCall.Parameter#createWithExpression(java.lang.String, java.lang.String)` expects the parameter name and a JavaScript expression. The generated VoiceXML will be:

```xml
    <param name="parameter2" expr="2+3" />
    <param name="parameter3" expr="'string'" />
```

We set those parameters in the turn as _subdialogue parameters_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-33

### Implementing a subdialogue

!set branch subdialogue-implementation

To implement a subdialogue is not different from implementing a normal dialogue except that it must end with the
`<return>` VoiceXML element instead of `<exit>`, `<disconnect>`. To generate a `<return>`, our dialogue simply need to
return a `com.nuecho.rivr.voicexml.turn.last.Return`. The return can either return named values (JavaScript values) or a VoiceXML event.

Our dialogue ask for two numbers:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-31

To return those numbers as well as their sum, we prepare a `com.nuecho.rivr.voicexml.turn.VariableList`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-36

We need to be careful with variable declarations. Here, since we have numbers, we don't quote the values. The caller
will receive JavaScript numbers, not strings. The resulting VoiceXML will be something like:

```xml
    <var name="number1" expr="12" />
    <var name="number2" expr="10" />
    <var name="sum" expr="22" />
```

We can now pass the `com.nuecho.rivr.voicexml.turn.VariableList` in the `com.nuecho.rivr.voicexml.turn.last.Return`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 38-39

We also show here how to return an event by using the other constructor. Event name is passed in the
second parameter and message (optional) is passed in the third parameter:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 40-43

Here's a sample VoiceXML document invoking the subdialogue:

!inline src/main/webapp/main.vxml

To try the example, the VoiceXML platform initial URL should be `http://<yourhostname>:8080/rivr-cookbook/main.vxml`

### Reading subdialogue VoiceXML parameters

!set branch subdialogue-implementation-voicexml-parameter

First, make sure you understand the [[Implementing a subdialogue]] example. The following example will show you
how to read the parameters sent to a subdialogue using the `<param>` VoiceXML element:

!inline src/main/webapp/main.vxml 5-7

We are going the obtain the subdialogue parameters by declaring variables in the first output turn of the dialogue:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-31

Note that the variable declaration can contain an initial expression. In this case, the expression will act as the
default value of the parameters. This is shown above with the `promptText2` parameter.

Those declaration must be included in a `com.nuecho.rivr.voicexml.turn.output.Script` turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-34

This turn is then executed and the subdialogue parameters are available as properties of the `jsonValue`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 36-39

# Using vendor-specific VoiceXML platform extensions

## Genesys Voice Platform 8 (GVP 8)

### Obtaining UUID

!set branch genesys-gvp-uuid

GVP Call UUID is exposed under `session.connection.uuid`. We use a `com.nuecho.rivr.voicexml.turn.output.Script` turn to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 19-36

### Obtaining GVP session ID

!set branch genesys-gvp-session-id

GVP Session ID is exposed under `session.com.genesyslab.sessionid`. We use a `com.nuecho.rivr.voicexml.turn.output.Script` turn to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 19-37

### Reading user data

!set branch genesys-gvp-read-user-data

This example assumes a SIP Server integration (not the CTI connector).

This example shows how to extract user data sent by the SIP Server at the beggining of the call. The SIP server sends the user
data in specific headers of the SIP INVITE message, typically the ones prefixed with `X-Genesys-`:

    X-Genesys-CustomerName: Peter Johnson
    X-Genesys-AccountNumber: 55534-53124-67110

GVP will map these headers to the `session.com.genesyslab.userdata` object, making it available to the VoiceXML application. We only
need to use a `com.nuecho.rivr.voicexml.turn.output.Script` to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 21-48

Note that if user data are updated during the GVP call, the updated data cannot be read from the VoiceXML because it's only passed from
SIP Server to GVP in the SIP INVITE _at the beggining of the call_.

# Integration

## JUnit

### Simple dialogue tests

Unit testing is one of Rivr most notable feature. It allows the developer to perform non-regression testing with automated tools. Using this technique, you can
simulate hundreds of call in seconds.

!set branch junit-dialogue-test

Suppose we have a simple dialogue and we want to write unit tests for it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 25-79

We first need to write a unit test class in which we will initialize a `com.nuecho.rivr.voicexml.test.VoiceXmlTestDialogueChannel` which is an implementation of `com.nuecho.rivr.core.channel.DialogueChannel` used for testing. This implementation allows us to simulate responses from the VoiceXML platform such as recognition results and no-match events.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 31-34

This dialogue channel must be set in the dialogue context we will use in our test cases:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 36-41

The rest of the class is a mix of test methods (annotated with `@org.junit.Test` annotation) and helper methods.

Let's take a look at our first test case:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 43-59

The first thing to do is to start the dialogue.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 45-45

We have used the `startDialogue()` helper method to do so:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 139-141

We then need to perform some kind of check to validate that the dialogue is executing correctly. We know that the first thing the dialogue should do is to play the welcome message, so let's verify that:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 46-46

Since other test cases also require to perform this check, we have extracted the logic in the `assertWelcomeMessage()` helper method:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 143-145

The `assertMessage()` method ensure that the dialogue is generating a `com.nuecho.rivr.voicexml.turn.output.Message` turn and that the audio items are as expected:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 161-166

Note that in this method, we use the `com.nuecho.rivr.core.test.TestDialogueChannel#getLastStepAsOutputTurn()` method on our test dialogue channel to query the last _step_ that
occured in the channel. The step can be one of:

* Output turn
* Last turn
* Error

Depending on the expected type of step at this point in the dialogue, we can invoke respectively

* `com.nuecho.rivr.core.test.TestDialogueChannel#getLastStepAsOutputTurn()`
* `com.nuecho.rivr.core.test.TestDialogueChannel#getLastStepAsLastTurn()`
* `com.nuecho.rivr.core.test.TestDialogueChannel#getLastStepAsError()`

So the `assertMessage()` method will ensure

1. that we have, at this point in the dialogue, an `com.nuecho.rivr.core.channel.OutputTurn` for which the type is `com.nuecho.rivr.voicexml.turn.output.Message`
2. that the audio items of this message turn are as expected

Note that we are only asserting some aspects of the `com.nuecho.rivr.voicexml.turn.output.Message`. We didn't test neither the `language` nor `barge-in` properties.
Thus it's possible to make the test cases as sophisticated as needed. There's always a trade-off between what is actually asserted in
unit tests and the effort required to develop those test cases. You have control over what you depth of assertion for each turn.

Geting back at our example, now we'll simulate the VoiceXML platform response. In this case, since we have a message, the only possible response
from the platform (beside an `error` event) is what we call a _no-action_, i.e. an input turn without any property set. In order to simulate this platform response, we invoke the
`com.nuecho.rivr.voicexml.test.VoiceXmlTestDialogueChannel#processNoAction()` method on the dialogue channel:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 48-48

The dialogue will then progress to the next turn.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 49-49

The `assertPromptForNumber()` validates that we have an interaction turn, parameterized for DTMF recogition and having some specific messages:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 147-151

This method uses two additionnal helper methods `assertDtmfInteraction` and `assertInteraction`:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 168-182

Again, we see that we can build many reusable helper methods that will make each test case very terse.

To simulate DTMF processing, including semantic result, we do:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 51-51

The first argument is the raw input (DTMF recognizer will sometimes separate digits with spaces), the second one is the semantic result, the third one is a mark
info (not covered here). Next step is to validate the feedback message:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 52-52

At this point, you may have noticed that we have always follow this pattern:

* perform some action
* assert something

Using a white line between each block will help you remain organized in you test case method code.

To assert the result of the dialogue, we only need to assert the `com.nuecho.rivr.core.channel.LastTurn`:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 55-58

With `assertExit()` defined as:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 184-190

If we only run JUnit for the test case `testNormal()` we do not completely every outcome of the callflow. This can be verified by running JUnit in conjunction
with a coverage tool. I will be using [Emma](http://emma.sourceforge.net/) with the [Eclipse plug-in](http://www.eclemma.org/):

![Emma code coverage in Eclipse](http://nuecho.github.io/rivr/cookbook-resources/0.9.3/eclipse-coverage-1.png "Emma code coverage in Eclipse")

Adding 3 other test cases, we can achieve complete coverage:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 61-137

![Emma code coverage in Eclipse](http://nuecho.github.io/rivr/cookbook-resources/0.9.3/eclipse-coverage-2.png "Emma code coverage in Eclipse")

## Server-side integration

### Spring framework integration

!set branch spring

There are so many ways you can leverage the [Spring framework](http://projects.spring.io/spring-framework/).
This example will show you how to provide a custom dialogue factory that will create `com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogue` objects
from the Spring bean factory.

The first step is to create a Dialogue as a Java bean:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 16-41

Note that this dialogue has a mandatory _message_ property.

Now in the bean factory configuration file, we can provide some definitions for some _dialogue beans_:

!inline src/main/webapp/WEB-INF/applicationContext.xml

We make those beans as _prototype_, meaning that they are reinstanciated each time they are requested. This is required
if the dialogue class is stateful (which is not really the case in our example). A stateless dialogue bean can be
shared across many "phone calls" while a stateful dialogue bean can only used by one call.

You need to set the application context in the web.xml:

!inline src/main/webapp/WEB-INF/web.xml 8-10

We can define a custom dialogue factory that will lookup the dialogue in the bean factory according to
the value of the `dialogue` HTTP parameter:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/DialogueFactory.java 20-56

You need to place the name of the dialogue factory class in the `web.xml`:

!inline src/main/webapp/WEB-INF/web.xml 16-19

You can try it with the following URI:

- [http://localhost:8080/rivr-cookbook/dialogue?dialogue=x](http://localhost:8080/rivr-cookbook/dialogue?dialogue=x)
- [http://localhost:8080/rivr-cookbook/dialogue?dialogue=y](http://localhost:8080/rivr-cookbook/dialogue?dialogue=y)

# Other recipes

## Extending Rivr

Rivr can be extended and customized in different ways. If for some reason, the output and last turns provided 
by Rivr aren't sufficient, there's always a way out. There are two mechanisms that can be used to extend the 
fonctionality of Rivr.

The first technique is to customize the VoiceXML generated by a turn. The typical case is to add a 
platform-specific attribute on a VoiceXML element. To do that, we set an instance of
 `com.nuecho.rivr.voicexml.turn.VoiceXmlDocumentAdapter` on the 
`com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn` or the
`com.nuecho.rivr.voicexml.turn.last.VoiceXmlLastTurn`. 
The `com.nuecho.rivr.voicexml.turn.VoiceXmlDocumentAdapter`
is an interface with one single method:

    void adaptVoiceXmlDocument(Document voiceXmlDocument) throws VoiceXmlDocumentRenderingException

This method allows an implementing class to change the content of the VoiceXML document by modifying 
the structure of the `org.w3c.dom.Document`. The manipulation of this object is done by using the standard 
DOM API.

The second technique is to create a new subclass of `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn` or
`com.nuecho.rivr.voicexml.turn.last.VoiceXmlLastTurn`. When creating this class, the developper has full 
control over the generated VoiceXML content. 

The following examples show how to realize both of the previous techniques.

### Customizing an OutputTurn with VoiceXmlDocumentAdapter

(to be added)

### Adding a custom log turn

!set branch log-turn

In this example, we will see how to add a `LogTurn` class which will provide a way to generate simple
VoiceXML `<log>` statements like this:

    <log label="myLabel">This is a log message.</log>

When executed by the platform, these statements will do client-side logging (the content will be logged in the
VoiceXML platform system logs, not on the Java web server side).  

First, we need to define a class extending `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn`:

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 21-21

Let's have 2 fields:

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 23-24

Now we need to provide a method to generate VoiceXML content. We have the choice to either override 
one of the following methods:

  * `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#createVoiceXmlDocument(com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext)`
  * `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#fillVoiceXmlDocument(org.w3c.dom.Document, org.w3c.dom.Element, com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext)`

If we override `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#createVoiceXmlDocument(com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext)`, 
we need to generate every bit of the VoiceXML document. However, if we override 
`com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#fillVoiceXmlDocument(org.w3c.dom.Document, org.w3c.dom.Element, com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext)`
most of the document is already built. So we're provided with a template in which we only need to place 
content in a VoiceXML form:

```xml

<?xml version="1.0" encoding="UTF-8"?>
<vxml
    application="/rivr-cookbook/dialogue/root/d107d7bc-0553-4140-afcb-cfcc94630fbc"
    version="2.1" xmlns="http://www.w3.org/2001/vxml">
    <script>application.rivr.localErrorHandling = false; application.rivr.inputTurn = {};</script>
    <form id="form">

        <!-- This is the form element used by fillVoiceXmlDocument() -->

    </form>
    <catch>
        <if cond="_event.substring(0, 5) == &quot;error&quot;">
            <if cond="application.rivr.localErrorHandling">
                <goto next="#fatalErrorForm"/>
                <else/>
                <script>application.rivr.localErrorHandling=true</script>
            </if>
        </if>
        <script>application.rivr.addEventResult(_event, _message)</script>
        <goto next="#submitForm"/>
    </catch>
    <form id="fatalErrorForm">
        <block>
            <exit/>
        </block>
    </form>
    <form id="submitForm">
        <block>
            <var
                expr="application.rivr.toJson(application.rivr.inputTurn)" name="inputTurn"/>
            <if cond="application.rivr.hasRecording(application.rivr.inputTurn)">
                <var
                    expr="application.rivr.inputTurn.recordingMetaData.data" name="recording"/>
                <assign expr="undefined" name="application.rivr.inputTurn.recordingMetaData.data"/>
                <submit enctype="multipart/form-data" method="post" namelist="inputTurn recording"
                        next="/rivr-cookbook/dialogue/d107d7bc-0553-4140-afcb-cfcc94630fbc/0/logging"/>
                <else/>
                <submit method="post" namelist="inputTurn"
                        next="/rivr-cookbook/dialogue/d107d7bc-0553-4140-afcb-cfcc94630fbc/0/logging"/>
            </if>
        </block>
    </form>
</vxml>
```

The template will contain all the relevant error handling elements and everything required to send the result
back to the dialogue servlet (i.e. the `submitForm`). When creating a custom turn, all that is required is to
*goto* the `submitForm` at the end.

So let's override the `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#fillVoiceXmlDocument(org.w3c.dom.Document, org.w3c.dom.Element, com.nuecho.rivr.voicexml.dialogue.VoiceXmlDialogueContext)`.

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 37-39

The first thing to do is to create our `<log>` element.  To do that, we can use the standard methods for the DOM API.  
However here, we will use an utility class provided with Rivr, `com.nuecho.rivr.core.util.DomUtils`.

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 40-40

Note that `com.nuecho.rivr.voicexml.rendering.voicexml.VoiceXmlDomUtil` also contains useful VoiceXML-related
constants and methods. 

We set the `label` attribute (if not `null`):

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 41-43

Then we add the log statement in the element:

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 45-47

At the very end, we create a `<goto>` statement to the `submitForm`.  There's a helper method for that:

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 49-49

When deriving the `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn` class, two other methods must be 
provided. 

The system needs to have a text description of the type of turn that we are adding to the system.  To do that,
we override the `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn#getOuputTurnType()` method:
 
!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 32-35

The last method we need to override is `com.nuecho.rivr.voicexml.turn.VoiceXmlDocumentTurn#addTurnProperties(javax.json.JsonObjectBuilder)`. 
We need to give a JSON description of the custom turn we've just created:

!inline src/main/java/com/nuecho/rivr/cookbook/turns/LogTurn.java 52-61

The properties specified with those methods will be displayed in the *dialogue runner* web interface. 
They have no impact on the generated VoiceXML. So when using the dialogue runner, you'll be able to inspect 
this turn in the JSON view (i.e. type of turn and properties).  

Now, we can use our new type of turn in a regular dialogue:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 21-30
 
This is the result:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<vxml
    application="/rivr-cookbook/dialogue/root/df85987d-619d-4747-9ec1-60ee52b1985e"
    version="2.1" xmlns="http://www.w3.org/2001/vxml">
    <script>application.rivr.localErrorHandling = false; application.rivr.inputTurn = {};</script>
    <form id="form">
        <log label="debug">this is a logging statement</log>
        <goto next="#submitForm"/>
    </form>
    <catch>
        <if cond="_event.substring(0, 5) == &quot;error&quot;">
            <if cond="application.rivr.localErrorHandling">
                <goto next="#fatalErrorForm"/>
                <else/>
                <script>application.rivr.localErrorHandling=true</script>
            </if>
        </if>
        <script>application.rivr.addEventResult(_event, _message)</script>
        <goto next="#submitForm"/>
    </catch>
    <form id="fatalErrorForm">
        <block>
            <exit/>
        </block>
    </form>
    <form id="submitForm">
        <block>
            <var expr="application.rivr.toJson(application.rivr.inputTurn)" name="inputTurn"/>
            <if cond="application.rivr.hasRecording(application.rivr.inputTurn)">
                <var expr="application.rivr.inputTurn.recordingMetaData.data" name="recording"/>
                <assign expr="undefined" name="application.rivr.inputTurn.recordingMetaData.data"/>
                <submit enctype="multipart/form-data" method="post" namelist="inputTurn recording" 
                        next="/rivr-cookbook/dialogue/df85987d-619d-4747-9ec1-60ee52b1985e/0/logging"/>
                <else/>
                <submit method="post" namelist="inputTurn" 
                        next="/rivr-cookbook/dialogue/df85987d-619d-4747-9ec1-60ee52b1985e/0/logging"/>
            </if>
        </block>
    </form>
</vxml>
```

NOTE: This is just an example. A proper logging extension should not create a VoiceXML document for 
the sole purpose of logging. The logging statements should rather be accumulated in memory and flushed every time 
a `com.nuecho.rivr.voicexml.turn.output.VoiceXmlOutputTurn` or 
`com.nuecho.rivr.voicexml.turn.last.VoiceXmlLastTurn` is generated. This could be accomplished with the 
`com.nuecho.rivr.voicexml.turn.VoiceXmlDocumentAdapter` mechanism.  See [[Customizing an OutputTurn with VoiceXmlDocumentAdapter]].

## Getting information from HTTP

### Extracting HTTP parameters

!set branch http-parameters

This example shows how to extract HTTP parameters and used them in a dialogue. The parameters can be passed in the query string (e.g. `http://localhost:8080/rivr-cookbook/dialogue?name=value`) or in the body of the request (content-type: application/x-www-form-urlencoded), such as a POST.

HTTP parameters can be obtained in the `com.nuecho.rivr.voicexml.turn.first.VoiceXmlFirstTurn` with the `com.nuecho.rivr.voicexml.turn.first.VoiceXmlFirstTurn#getParameters()` method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 22-22

Here, we use the parameters names and values to play a message:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 24-31

## Getting information from the platform

### Getting CLID and DNIS

!set branch clid-dnis

This example shows how to get the CLID (also known as ANI) and DNIS from the VoiceXML platform. To do that, we need to read two read-only
[variables specified by the VoiceXML specification](http://www.w3.org/TR/voicexml20/#dml5.1.4):

> `session.connection.local.uri`

>> This variable is a URI which addresses the local interpreter context device.

> `session.connection.remote.uri`

>> This variable is a URI which addresses the remote caller device.

To create a VoiceXML document reading platform variables, we use the `com.nuecho.rivr.voicexml.turn.output.Script` turn. This turn will generate a VoiceXML document that will perform the following step:

1. Initialize some variables with some optional expression.
2. Execute an optional script
3. Send back the variables to the server

Here, we will only need to initialize two variables and send the result back to our dialogue, no need for a script here as initial value assignment is enough.
To define the variables and initial expression, we use the `com.nuecho.rivr.voicexml.turn.VariableList` class:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 23-25

Then we create the `com.nuecho.rivr.voicexml.turn.output.Script` turn with theses variable definitions:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 27-28

We execute the turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-30

To retrieve the result, we cast the result from `com.nuecho.rivr.voicexml.turn.input.VoiceXmlInputTurn#getValue()` into a `JsonObject`. The affected values for the variables can be obtained as property of this object:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 32-35

Note that the CLID and DNIS obtained this way are URI. If you have a SIP IVR platform integrated with the PSTN, you are likely to get SIP URI (e.g. `sip:+15145551234@proxy.example.com`) so you probably need to do some parsing in order to extract the numeric value of the SIP URI.
